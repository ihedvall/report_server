/*
 * Copyright 2022 Ingemar Hedvall
 * SPDX-License-Identifier: MIT
 */

#include <filesystem>
#include <chrono>
#include <algorithm>

#include "ods/imodel.h"
#include "util/ixmlfile.h"
#include "util/logstream.h"
#include "util/timestamp.h"
using namespace util::xml;
using namespace util::log;
using namespace util::time;

namespace {
void ReadColumn(const IXmlNode& node, ods::ITable& table) {
  ods::IColumn col;

  if (node.ExistProperty("Name")) {
    col.ApplicationName(node.Property<std::string>("Name"));
  } else {
    col.ApplicationName(node.Attribute<std::string>("name"));
  }

  if (node.ExistProperty("ColumnName")) {
    col.DatabaseName(node.Property<std::string>("ColumnName"));
  } else {
    col.DatabaseName(node.Attribute<std::string>("column"));
  }

  col.Description(node.Property<std::string>("Description"));
  col.DisplayName(node.Property<std::string>("DisplayName"));
  col.BaseName(node.Property<std::string>("BaseName"));

  col.ReferenceName(node.Property<std::string>("RefColumnName"));


  col.ReferenceId(node.Property<int64_t>("RefId"));

  const auto* type = node.GetNode("Type");
  if (type != nullptr) {
    col.DataType(ods::TextToDataType(type->Value<std::string>()));
    if (node.ExistProperty("Unit")) {
      col.Unit(node.Property<std::string>("Unit"));
    } else {
      col.Unit(type->Attribute<std::string>("unit"));
    }

    if (node.ExistProperty("EnumName")) {
      col.EnumName(node.Property<std::string>("EnumName"));
    } else {
      col.EnumName(type->Attribute<std::string>("enum"));
    }

    if (node.ExistProperty("Decimals")) {
      col.NofDecimals(node.Property<size_t>("Decimals"));
    } else {
      col.NofDecimals(type->Attribute<size_t>("decimals"));
    }
    if (node.ExistProperty("Length")) {
      col.DataLength(node.Property<size_t>("Length"));
    } else {
      col.DataLength(type->Attribute<int>("length"));
    }
  }

  const auto* flags = node.GetNode("Flags");
  if (flags != nullptr) {
    uint16_t temp = 0;
     if (flags->Attribute<bool>("auto")) {
       temp |= ods::kAutoGenerated;
     }
    if (flags->Attribute<bool>("unique")) {
      temp |= ods::kUnique;
    }
    if (flags->Attribute<bool>("index")) {
      temp |= ods::kIndex;
    }
    if (flags->Attribute<bool>("obligatory")) {
      temp |= ods::kObligatory;
    }
    if (flags->Attribute<bool>("casesensitive")) {
      temp |= ods::kCaseSensitive;
    }
    col.Flags(temp);
  }
  table.AddColumn(col);
}

}
namespace ods {

void IModel::AddTable(const ITable &table) {
  auto* parent = table.ParentId() != 0 ? const_cast<ITable*>(GetTable(table.ParentId())) : nullptr;
  if (parent != nullptr) {
    parent->AddSubTable(table);
  } else {
    table_list_.insert({table.ApplicationId(), table});
  }
}

void IModel::AddEnum(const IEnum& obj) {
  enum_list_.insert({obj.EnumName(), obj});
}

bool IModel::ReadModel(const std::string &filename) {
  auto xml_file = CreateXmlFile();
  if (!xml_file) {
    LOG_ERROR() << "Failed to create the XML parser. File: " << filename;
    return false;
  }
  xml_file->FileName(filename);
  const auto parse = xml_file->ParseFile();
  if (!parse) {
    LOG_ERROR() << "XML parser error. File: " << filename;
    return false;
  }
  if (xml_file->RootName() != "OdsModel") {
    LOG_ERROR() << "Invalid root tag. Tag: " << xml_file->RootName() << ", File: " << filename;
    return false;
  }
  table_list_.clear();
  enum_list_.clear();
  Name(xml_file->Property("Name",std::string("")));
  if (Name().empty()) {
    try {
      std::filesystem::path file(filename);
      Name(file.stem().string());
    } catch (const std::exception& ) {
    }
  }
  Version(xml_file->Property("ApplicationVersion",std::string("")));
  Description(xml_file->Property("Description",std::string("")));
  CreatedBy(xml_file->Property("CreatedBy",std::string("")));
  ModifiedBy(xml_file->Property("ModifiedBy",std::string("")));
  BaseVersion(xml_file->Property("BaseVersion",std::string("")));

  Created(IsoTimeToNs(xml_file->Property("Created",std::string(""))));
  Modified(IsoTimeToNs(xml_file->Property("Modified",std::string(""))));

  if (Modified() == 0) {
    try {
      std::filesystem::path file(filename);
      const auto last = std::filesystem::last_write_time(file);
      const auto sys_time = std::chrono::file_clock::to_sys(last);
      const uint64_t ns1970 = util::time::TimeStampToNs(sys_time);
      Modified(ns1970);
    } catch (const std::exception& ) {
    }
  }
  if (Created() == 0) {
    Created(Modified());
  }

  IXmlNode::ChildList node_list;
  xml_file->GetChildList(node_list);
  for (const auto& node : node_list) {
    if (!node) {
      continue;
    }
    if (node->IsTagName("Enum") || node->IsTagName("Enumerate")) {
      ReadEnum(*node);
    } else if (node->IsTagName("EnumList")) {
       IXmlNode::ChildList enum_list;
       node->GetChildList(enum_list);
       for (const auto& node1 : enum_list) {
         if (node1->IsTagName("Enum")) {
           ReadEnum(*node1);
         }
       }
    } else if (node->IsTagName("Element") || node->IsTagName("Table")) {
      ReadTable(*node);
    }
  }
  return true;
}

void IModel::ReadEnum(const IXmlNode &node) {
  IEnum obj;
  if (node.ExistProperty("EnumName")) {
    obj.EnumName(node.Property<std::string>("EnumName"));
  } else {
    obj.EnumName(node.Attribute<std::string>("name"));
  }

  if (node.ExistProperty("Locked")) {
    obj.Locked(node.Property<bool>("Locked"));
  } else {
    obj.Locked(node.Attribute<bool>("locked"));
  }

  IXmlNode::ChildList item_list;
  node.GetChildList(item_list);
  for (const auto& item : item_list) {
    if (!item->IsTagName("Item")) {
      continue;
    }
    const int64_t item_no = item->ExistProperty("ItemNo") ?
        item->Property<int64_t>("ItemNo") : item->Attribute<int64_t>("number");
    const std::string item_text = item->ExistProperty("ItemName") ?
        item->Property<std::string>("ItemName") : item->Attribute<std::string>("value");
     obj.AddItem(item_no, item_text);
  }
  AddEnum(obj);
}

void IModel::ReadTable(const IXmlNode &node) {
  ITable table;
  if (node.ExistProperty("Id")) {
    table.ApplicationId(node.Property<int64_t>("Id"));
  } else {
    table.ApplicationId(node.Attribute<int64_t>("id"));
  }

  if (node.ExistProperty("ParentId")) {
    table.ParentId(node.Property<int64_t>("ParentId"));
  } else {
    table.ParentId(node.Attribute<int64_t>("parent"));
  }

  if (node.ExistProperty("BaseId")) {
    table.BaseId(static_cast<BaseId>(node.Property<int>("BaseId")));
  } else {
    table.BaseId(static_cast<BaseId>(node.Attribute<int>("base")));
  }

  table.BaseId(static_cast<BaseId>(node.Property<int>("BaseId")));

  if (node.ExistProperty("Name")) {
    table.ApplicationName(node.Property<std::string>("Name"));
  } else {
    table.ApplicationName(node.Attribute<std::string>("name"));
  }

  if (node.ExistProperty("TableName")) {
    table.DatabaseName(node.Property<std::string>("TableName"));
  } else {
    table.DatabaseName(node.Attribute<std::string>("table"));
  }
  IXmlNode::ChildList column_list;
  node.GetChildList(column_list);
  for (const auto& col : column_list) {
    if (col->IsTagName("Attribute")) {
      ::ReadColumn(*col, table);
    }
  }
  AddTable(table);
}

const ITable *IModel::GetTable(int64_t application_id) const {
  const auto itr = table_list_.find(application_id);
  if (itr != table_list_.cend()) {
    return &itr->second;
  }
  for (const auto& table : table_list_ ) {
    const auto* find = table.second.GetTable(application_id);
    if (find != nullptr) {
     return find;
    }
  }
  return nullptr;
}

const IEnum *IModel::GetEnum(const std::string& name) const {
  const auto itr = enum_list_.find(name);
  return itr == enum_list_.cend() ? nullptr : &itr->second;
}

const ITable *IModel::GetBaseId(BaseId base) const {
    // Search on top level first which is the normal case for this function
  const auto itr1 = std::ranges::find_if(table_list_, [&] (const auto& itr) {
    return itr.second.BaseId() == base;
  });
  if (itr1 != table_list_.cend()) {
    return &itr1->second;
  }
    // Plan B is to do a deep search
  for (const auto& itr2 : table_list_) {
    const auto* table = itr2.second.GetBaseId(base);
    if (table != nullptr) {
      return table;
    }
  }
  return nullptr;
}

const ITable *IModel::GetTableByName(const std::string &name) const {
  for (const auto& itr : table_list_) {
    const auto& table = itr.second;
    const auto* find = table.GetTableByName(name);
    if (find != nullptr) {
      return find;
    }
  }
  return GetTableByDbName(name);
}

const ITable *IModel::GetTableByDbName(const std::string &name) const {
  for (const auto& itr : table_list_) {
    const auto& table = itr.second;
    const auto* find = table.GetTableByDbName(name);
    if (find != nullptr) {
      return find;
    }
  }
  return nullptr;
}
} // end namespace